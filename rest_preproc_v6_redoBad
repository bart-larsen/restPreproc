#!/bin/bash

######## HELP #############
# /Volumes/Serena/Rest/rest_scripts/rest_preproc_v6_redoBad -a afni -s 10674 -p
# Version: single subject ROI_Corr 2012-09-12
# Creates: rest_preproc_mni in subjectdir/pipeTest/pipelineSuffix
# Options
#   -s subject   required
#   -t <ort|3dD> bandpass with ort or 3dDeconvolved,3dD is default)
#   -p           use physio, -t is useless for this
#   -a           run portion again (<mprage,afni,bp>)
#   -x           take pictures, make a graph
#   -h           this
#   .noPhysio_afniproc   ~600MB - $noPhysioDirSuffix - flirt of afni_proc outputs and regressors (*1D)
# 
# FINAL OUT: rest_preproc_mni
#END ######

#Will   09/12/2012 - include @ROI_Corr_Mat, change overview function
#Will   09/04/2012 - remove for loop so this script can be used with additional wrapper and job control
#Will   08/22/2012 - rewrite for three piplines withPhysio, bp+ort_noPhyso, bp+3dD_noPhyso 
#Will   08/06/2012 - setting pipeline to "bad" bandpass, regress for comparison
#Aarthi 06/12/2012 - redoing preprocess to make the alignment better. using FLIRT to align EPI to mprage. 
#

#12-08-2011
#preprocess rest functinal
#normalize to MNI brain
#added afni's anaticor method to remove local nuisance signals
#convert to bash

#'Mapping sources of correlation in resting state FMRI, with 
# artifact detection and removal'
#       Jo, et al., Neuroimage, Vol 52 (2), 571-582, 2010.
#       [http://dx.doi.org/10.1016/j.neuroimage.2010.04.246]


set -e #-nv

scriptAndArgs="$0 $@"
version=$(sed -n 's/^# Version://p' $0)
bb244=/Volumes/Serena/Rest/Subjects/stats/science_regions/bb244+tlrc
mniBrain=~/standard/fsl_mni152/MNI152_T1_2mm.nii.gz
subjectDir=/Volumes/Serena/Rest/Subjects/
prefix=pipeTests
mprageDirSuffix=.inputsAndAlignments
noPhysioDirSuffix=.noPhysio_afniproc
physo=no         # uses phsyo data: no, with|yes 
pipetype='3dD'   # which pipeline: simul (ort), bp first (3dD)
pics=no          # pictures and pipeline graph
dirty=no         # don't save all the output


## OPTIONS
while getopts 'a:s:t:dxph' opt; do
 case $opt in
  a) again=$OPTARG;;              # <mprage, afni|phys, bp>, what part to start doing again
  p) physo=with;;                 # default no, use physo data?
  s) subj=$OPTARG;;               # ** REQUIRED, what subject to use (just an ID, see subjectDir)
  t) pipetype=$OPTARG;; # <ort|3dD> default: 3dD 
  x) pics=yes;;                   # default no
  d) dirty=yes;;                  # save outputs, default is no
  *) sed -ne 's/^# //p;/^#END/q' $0; exit;; # help
 esac
done

s=$subjectDir/$subj
[ ! -d $s -o ! -d   /Volumes/Serena/Rest/FS_Subjects_AP/${subj}/mri ] && echo "no directory or FS for subject!" && exit


# pipetype is ort or 3dD
pipelineSuffix="withPhysio"; 
if [[  "$pipetype" =~ "ort" ]]; then pipetype="ort"; else pipetype="3dD"; fi
if [[ "$physo" =~ yes|with ]]; then physo=with;pipetype="physio"; else phsyo=no; fi
[ "$physo" = "no" ] && pipelineSuffix="bp+${pipetype}_noPhysio";
# physio is with or no
# if phsyio is with, ignore pipetype

# pipelineSuffix is now one of:
#  withPhysio
#  bp+ort_noPhysio  (sim)
#  bp+3dD_noPhysio  (bpreg)


# do we need to do anything again?
[ -z "$fresh" ]        && fresh=no      # pulls fresh from freesurfer, same as again=mprage
[ -z "$again" ]        && again=        # do this part of the pipeline again: mprage, afni|phys, bp


############ all the good stuff

## general prepration per subject, some redudant varaibles 
    subjdir=$s
       subj=$(basename $s)
piperootDir=$subjdir/$prefix
  mprageDir=$piperootDir/$mprageDirSuffix
nophysioDir=$piperootDir/$noPhysioDirSuffix
pipelineDir=$piperootDir/$pipelineSuffix

## pictures/screenshots and graph, log
 imgdir=$piperootDir/.tmpimg;  globalcount=0; graphstage=start;
logfile=$piperootDir/preproc-$pipelineSuffix.log

 [ -d $piperootDir ] || mkdir -p $piperootDir
 [ -d $imgdir ] || mkdir $imgdir
 while [ -r $logfile ]; do logfile="$logfile.new"; done
###########################


set -x
function stamp {
   echo "$(date +%F/%H%M) -- $@ -- $scriptAndargs -- $version" >> stamp
}
# someting new happened, print to screen, log in logfile
function alert { 
  echo -n "** "
  echo "$@ -- $(date +%F/%H:%M)" | tee -a $logfile
}
# remove .nii .nii.gz .BRIK .HEAD ...
function rm_ext { 
   basename $@ |perl -pe 's/\.(nii|BRIK|HEAD)(\.gz)?$//i' 
}

# function for
# - logging global count, action, and produced file
# - taking sequential processing pictures
# - creating dot graph
#    - diffent graph when $graphstage changes
### usage:  _overview createded_file -inputOne -inputFileTwo "explination of what's going on"
function _overview {
   newgraphFile="$imgdir/pipeline_${graphstage}.dot";

   # clear out the new graphfile if it is new
   [ "$newgraphFile" != "$graphFile" ] && graphFile="$newgraphFile" && echo -n "" > $newgraphFile

   globalcount=$((( $globalcount+ 1))) #let ..++ can return 0 and break things with set -e 

   # file created
   name=$(rm_ext "$1"); shift;
   nname=${name%\+orig}; nname=${nname//./_}

   # where is this file in the list of all files (what number)
   num=$(printf "%04d" $globalcount)
   imgname=$imgdir/${num}_$name.png

   # get all the inputs 
   # build all the edges
   # use -input to set edges 
   edges=
   while [[ -n "$1" && $1 =~ ^- ]]; do
    innode=$1; innode=$(rm_ext "${innode:1}")
    innode=${innode%\+orig}
    innode=${innode//./_}
   # edges="$edges  $innode -> $nname \n"
    edges="$edges $innode -> :${globalcount}:\n"
    shift;
   done

   # slicer needs nii files, create with 3dTcat if is in afni format
   if ls $name.nii* 2>/dev/null; then
    file=$name.nii*
   elif ls $nname+* 2>/dev/null; then
     # as nifti for slicer
     3dTcat $nname+*.BRIK[0] -prefix tmp.nii.gz -overwrite
     file=tmp.nii.gz
   else 
     file=
   fi


   action="$@";
   action=${action// /_}
   action=${action//./_}
   alert "$num $@ -> $nname" 

   # only do this if we are told to
   [ "$pics" == "yes" ] || return 0
   ## write to graph

   # check we have a save directory
   if [ ! -d $imgdir ]; then
     mkdir -p $imgdir 
     echo "digraph p {" >> $graphFile
   fi

   echo "// $globalcount" >> $graphFile
   echo " $action [ shape=diamond, label=\"$@\" ] " >> $graphFile

   if [ -n "$file" ]; then
      # take a shot if it should be a nifti
      slicer -u $file -a $imgname
      convert -scale 192x64 -fill white -gravity southwest -annotate 0 "$num $name:  $@" $imgname $imgname
      # use image as node if we can
      echo " $nname [image=\"${num}_$name.png\" label=\"\", shape=none]" >> $graphFile
   fi
   
   # add description to each edge, and save
   #echo -e "$edges" | sed -e "/^ *\$/d; s/\$/[ label=\"$@\" ]/" >> $graphFile; # labels are now nodes!
   echo -e "$edges" | sed -e "/^ *\$/d;s/:${globalcount}:/$action/g" >> $graphFile;
   echo "$action -> $nname" >> $graphFile;

   return 0
}

# align mask from afni_proc to T1 as mask_al.nii.gz
function alignMask {
  fullmask=full_mask.${subj}
  betRPI=$mprageDir/mprage_bet_RPI.nii

  3dAFNItoNIFTI $fullmask+orig
  # use -minsampling 3  ?? -- speed things up
  flirt -v -in $fullmask    -ref $betRPI -init  $mprageDir/epi2brain.txt -applyxfm \
           -paddingsize 0.0 -dof 6 -interp nearestneighbour -o mask_al.nii.gz

  3dcopy mask_al.nii.gz mask_al+orig

  _overview "mask_al.nii.gz"               -$betRPI  -epi2brain.txt -$fullmask "align to T1";
}

# align mask and afniproc out to structral
# final out: rest_epi_RPI_errts_al_res
function alignErrts {
    errts=./errts.${subj}+orig
   betRPI=$mprageDir/mprage_bet_RPI.nii
  outname=./rest_epi_RPI_errts_al
  #while getopts 'i:o:' opt; do
  # case $opt in
  #  i) errts=$OPTARG;;
  #  o) outname=$OPTARG;;
  # esac
  #done
  while [ $# -gt 0 ] ; do case $1 in
    -i) errts=$2; shift 2;;
    -o) outname=$2; shift 2;;
    *) echo "$1 not understood by alignErrts" && return 1
  esac; done

  # start with nifti, end with _res+orig
  outname=$(rm_ext $outname).nii.gz
  
  # align errts functional to structural using FSL (flirt)
  # arthi decided to use DOF 6 because it is the most conservative (assumes EPI and mprage are the same size). went with trilinear interpolation
  # (default) because its faster. sinc is supposed to be the best, but it takes forever!!
  
  [[ "$errts" =~ '+orig' ]] && 3dAFNItoNIFTI -float $errts
  
  # use epi->T1 omat to align afni out to T1
  flirt -v -in ${errts%+*} -ref $betRPI -init $mprageDir/epi2brain.txt -applyxfm \
           -paddingsize 0.0 -dof 6 -o $outname 	

  # FSL strips away the TR. Bring it back!	
  3drefit -TR 1.500 $outname


  # convert aligned EPI to AFNI
  outnameAFNI=$(rm_ext $outname)+orig
  3dcopy  $outname $outnameAFNI
  
  # resample aligned errts to 3.125 x 3.125 x 4
  # functional resolution?
  outname_res=$(rm_ext $outname)_res
  3dresample -dxyz 3.125 3.125 4 -inset $outnameAFNI -prefix $outname_res

  _overview "$outname"     -$betRPI  -epi2brain.txt -$errts    "align to T1";
  _overview "$outname_res" -$outnameAFNI  "resample to 3.125x..x4";

  rm $outname 

}


################################ START!!!

alert "SUBJ: $subj;  $pipetype $again"

#
# Step 1. Align mprage and epi, create masks from Freesurfer segementation
[[ $again =~ "mprage"|all ]] && fresh="yes" && alert "set fresh at mprage"

if [ ! -r $mprageDir/meanfunc2betbrain.nii.gz -o "$fresh" = "yes" ] ; then 
            
   alert "starting mprage ($mprageDir)"
   graphstage=mprage
            
   # clean up previous outputs, make mprage folder
   [ -d  $mprageDir ] && rm -rf $mprageDir
   mkdir -p $mprageDir
   stamp "mprage start"

   # go to FS parcilations
   cd /Volumes/Serena/Rest/FS_Subjects_AP/${subj}/mri

   # convert mgz to nii if havne't already
   [ ! -r mprage.nii.gz     ] && mri_convert T1.mgz        mprage.nii.gz
   [ ! -r mprage_bet.nii.gz ] && mri_convert brainmask.mgz mprage_bet.nii.gz
   [ ! -r aseg.nii.gz       ] && mri_convert aseg.mgz      aseg.nii.gz
            
   # move freesurfer segmentation files to working directory
   mv {mprage_bet,mprage,aseg}.nii.gz $mprageDir/

   # go into working directory
   cd $mprageDir/

   #CANNOT DEOBLIQUE BECAUSE it changes number of slices which messes up the physio stuff. 
   #3dWarp -deoblique -prefix rest_epi_RPI_do rest_epi_RPI+orig
   
   
   # make AFNI formated inputs
   3dcopy mprage.nii.gz     mprage
   3dcopy aseg.nii.gz       aseg
   3dcopy mprage_bet.nii.gz mprage_bet
   3dcopy ${subjdir}/rest/all.nii.gz ./rest_epi


   # what'd we just do -- copied in the originals
   for img in mprage{,_bet} aseg; do globalcount=-1; _overview $img -FreeSurfer "copied from FS"; done
   globalcount=-1; _overview rest_epi -Scanner "copied from scanner output";


   # switch to RPI orientation for both func and anat files
   for image in mprage mprage_bet aseg rest_epi; do 
      3dresample -orient RPI -prefix ${image}_RPI   -inset ${image}+orig
      _overview "${image}_RPI" -${image} "orient to RPI"; globalcount=$((( globalcount-1 )))
   done
   globalcount=$((( globalcount+1 )))
   #3dresample -orient RPI -prefix mprage_RPI     -inset mprage+orig
   #3dresample -orient RPI -prefix mprage_bet_RPI -inset mprage_bet+orig
   #3dresample -orient RPI -prefix aseg_RPI       -inset aseg+orig
   #3dresample -orient RPI -prefix rest_epi_RPI   -inset rest_epi+orig

   
   # create WM, Ventricals, Non-brain-tissue(NBT) and GM masks
   
   3dcalc -a aseg_RPI+orig -expr 'amongst(a,2,7,41,46,77,78,79)'            -prefix WM
   3dcalc -a aseg_RPI+orig -expr 'amongst(a,4,5,14,15,43,44)'               -prefix Vent
   3dcalc -a aseg_RPI+orig -expr 'amongst(a,3,8,10,11,12,13,17,18,26,28)'   -prefix GM_L
   3dcalc -a aseg_RPI+orig -expr 'amongst(a,42,47,49,50,51,52,53,54,58,60)' -prefix GM_R
   3dcalc -a aseg_RPI+orig -expr 'amongst(a,16)' -prefix BS
   for m in WM Vent GM_L GM_R BS; do  _overview "$m+orig" -aseg_RPI "extract FS parcilation"; done
   
   3dcalc -a mprage_bet_RPI+orig -b WM+orig -c Vent+orig -d GM_L+orig \
          -e GM_R+orig -f BS+orig -expr '(a/a)-(b+c+d+e+f)'                 -prefix NBT
   _overview "NBT+orig" -mprage_bet_RPI -WM -Vent -GM_L -GM_R -BS "combine all NBT masked by brain";

   # erode masks by 1 voxel to reduce partial volume effect 
   3dcalc -a WM+orig -b a+i -c a-i -d a+j \
          -e a-j -f a+k -g a-k -expr 'a*(1-amongst(0,b,c,d,e,f,g))'         -prefix WM_erod
   _overview "WM_erod+orig" -WM  "erode WM";

   # after some test dont erode Ventrical masks, as no voxels will survive
   #3dcalc -a Vent+orig -b a+i -c a-i -d a+j \
   #       -e a-j -f a+k -g a-k -expr 'a*(1-amongst(0,b,c,d,e,f,g))'        -prefix Vent_erod
   
   3dcalc -a NBT+orig -b a+i -c a-i -d a+j \
          -e a-j -f a+k -g a-k -expr 'a*(1-amongst(0,b,c,d,e,f,g))'         -prefix NBT_erod
   _overview "NBT_erod+orig" -NBT  "erode NonBrainTissue";

   # also make nifti copies
   3dAFNItoNIFTI mprage_RPI+orig 
   3dAFNItoNIFTI mprage_bet_RPI+orig; ln -s mprage_bet_RPI.nii mprage_RPI_bet.nii # need as (basename $mprage)_bet.nii, used as other name elsewhere
   3dAFNItoNIFTI rest_epi_RPI+orig 
   _overview "mprage_RPI_bet" -mprage_bet_RPI  "symbolic link";





   ##### get mprage_RPI_warpcoef (used in apply warp)
   # this was done way at the bottom before
   rest_preprocessMprage -r MNI_2mm -n mprage_RPI.nii -d n
   #_overview "mprage_RPI_nonlinear_warp_MNI_2mm" -mprage_RPI  -MNI152_T1_2mm  "rest_preprocMprage";
   _overview "mprage_RPI_warpcoef"  -mprage_RPI  -MNI152_T1_2mm "rest_preprocMprage";
   ######


   #################
   ### MAT for epi to T1
   restRPI=rest_epi_RPI
   betRPI=mprage_bet_RPI.nii
   # get the average funcataional and strip the skull
   fslmaths $restRPI -Tmean func_mean	
   bet func_mean func_mean_bet	

   # align epi to T1
   flirt -v -in func_mean_bet -ref $betRPI -omat epi2brain.txt \
             -paddingsize 0.0 -dof 6 -o meanfunc2betbrain.nii.gz #-o func2brain_errts.nii.gz

   _overview "func_mean_bet" -$restRPI                "time mean and skullstriped functional";
   _overview "epi2brain.txt" -$betRPI  -func_mean_bet "epi to T1 matrix";
   ###################

   stamp "mprage finished"
   
else
 alert "skipped generating alignments and masks!"
fi      
###############/END generic for-everyone##################
   



##### BEGIN different pipelines


# need to do everything on from this point again
[[ $again =~ afni|phsy ]] && fresh="yes" && alert "set fresh at phsyio afni"

#if [ ! -d $pipelineDir -o "$fresh" = "yes" ]; then
  # if fresh, remove old
  #[ -r $pipelineDir ] && rm -r $pipelineDir


  #  withPhysio                     afni_proc (w/motion reg), maskave NBT, @ANATICOR, 3dbp (dont need global, WM, etc)
  #  bp+ort_noPhyso: good_nophysio: maskave orig epi, afni_proc (no reg), 3dbp -ort  (need global,WM,etc)
  #  bp+3dD_noPhyso: bad_nophysio:  maskave orig epi, afni_proc (no reg), 3dbp, 3dDeconvolve

  # go to prefix directory (in prep for afni_proc)
cd $mprageDir/..

case "$pipelineSuffix" in 
 'withPhysio') 
   mask_al_res=mask_al_res+orig

   [ ! -d $pipelineDir ] && fresh="yes"

   if [ "$fresh" = "yes" ]; then
      [ -r $pipelineDir ] && rm -r $pipelineDir

      alert "using phsyo pipeline"
      graphstage=withPhysio
      ### afni proc
      #########/Volumes/Serena/Rest/physio1D/10767_RetroTS.slibase.1D
      #########/Volumes/Serena/Rest/physio1D/10797_RetroTS.slibase.1D
      physio1d=/Volumes/Serena/Rest/physio1D/${subj}_RetroTS.slibase.1D
      [ ! -r $physio1d ] && alert "$subj has no physo, doing nothing" && exit 1

      #UNUSED: why not -regress_motion_per_run? b/c regress_no_motion? No need for these lines?
      afni_proc.py -bash -execute -out_dir $pipelineDir -scr_overwrite -subj_id ${subj} \
                   -dsets $mprageDir/rest_epi_RPI+orig \
                   -blocks tshift volreg mask scale regress \
                   -do_block despike ricor \
                   -ricor_regs  $physio1d \
                   -ricor_regress_method 'per-run' \
                   -tshift_opts_ts -tpattern seq+z -mask_apply epi \
                   -regress_errts_prefix errts -regress_no_motion  \
                   -regress_opts_3dD -GOFORIT 10
       
      # (meta) record what we just did
      for file in dfile.rall.1D errts.$subj full_mask.$subj; do _overview "$file" -rest_epi_RPI+orig "afni_proc"; done

      # mv generating script inside directory it generates
      mv proc.* output.proc* $pipelineDir
      cd $pipelineDir


      # align mask to structural using nearestneighbor interpolation		
      alignMask  # -> mask_al

      ## align to T1 
      alignErrts  # ->  rest_epi_RPI_errts_al_res
      T1alignedEPI=rest_epi_RPI_errts_al_res+orig

      1d_tool.py -infile dfile.rall.1D -set_nruns 1 -demean -write motion_demean.1D


      # resample (_res)
      3dresample -master $T1alignedEPI -inset $mprageDir/aseg_RPI+orig  -prefix ./aseg_RPI_res
      3dresample -master $T1alignedEPI -inset ./mask_al+orig            -prefix ./mask_al_res
      3dresample -master $T1alignedEPI -inset $mprageDir/NBT_erod+orig  -prefix ./NBT_erod_res

      ### maskave
      3dmaskave -mask NBT_erod_res+orig -q rest_epi_RPI_errts_al_res+orig  > NBT.1D

      _overview "motion_demean.1D" "-dfile.rall.1D" "create motion regressor";
      _overview "aseg_RPI_res" "-$T1alignedEPI" "-aseg_RPI" "resample aseget";
      _overview "$mask_al_res" "-$T1alignedEPI" "-mask_al" "resample aseget";
      #_overview "NBT.1D" "-NBT_erod_res+orig" -$T1alignedEPI  "maskave";
      _overview "mask_al_res+orig" -$T1alignedEPI -mask_al+orig  "resample mask";

      ### @ANATICOR
      anaticoreout=epi_res_al_physio+orig
      @ANATICOR -ts $T1alignedEPI \
                -motion motion_demean.1D -polort 3 \
                -aseg aseg_RPI_res+orig -radius 30 \
                -nuisance NBT.1D -no_ventricles    \
                -Rsq_WMe -coverage -verb           \
                -prefix $anaticoreout 
      
       _overview "$anaticoreout" "-rest_epi_RPI_errts_al_res+orig" "ANATICOR"

      ### 3dbp
      pipelineoutfile=${anaticoreout%+*}_bp.nii.gz # epi_res_al_physio+orig -> epi_res_al_physio_bp.nii.gz
      3dBandpass -prefix $pipelineoutfile  0.009 0.08 $anaticoreout
      _overview "$pipelineoutfile" -$anaticoreout "bandpass"
   else
    alert "Skipping withPhsyio"
    [ $again = "last" ] && fresh="yes"
    cd $pipelineDir
    pipelineoutfile=epi_res_al_physio_bp.nii.gz
   fi

  ;;


 *noPhysio)
   mask_al_res=$nophysioDir/mask_al_res+orig
    ########################################
    # Pipelines without physiological info #
    ########################################

   alert "using nophysio pipeline"
   ### afni_proc
    
   ## do the common part of the pipeline (namely flirt of mask and epi)
   [[ $again =~ align|afni|proc || ! -d $nophysioDir ]] && fresh="yes" && alert "set fresh at nophysio align"
   if [  "$fresh" = "yes" ]; then

      [ -d $nophysioDir ] && rm -r $nophysioDir
      
      alert "no physo afni proc"
      graphstage=noPhysio

      afni_proc.py -bash -execute -out_dir $nophysioDir -scr_overwrite -subj_id ${subj} \
                    -dsets $mprageDir/rest_epi_RPI+orig \
                    -blocks tshift volreg mask scale  \
                    -do_block despike \
                    -tshift_opts_ts -tpattern seq+z -mask_apply epi 
                    # removed regress from block

      # (meta) record what we just did
      for file in dfile.rall.1D full_mask.$subj+orig pb04_{$subj}_r01_scale; do _overview "$file" -rest_epi_RPI+orig "afni_proc"; done

      # mv generating script inside directory it generates
      mv proc.* output.proc* $nophysioDir
      cd  $nophysioDir


      # align mask to structural using nearestneighbor interpolation		
      alignMask # $fullmask -> mask_al{+orig,.nii.gz}

      # aligned and resampeld -> epi_aproc_al_res+orig
      alignErrts -i ./pb04.$subj.r01.scale+orig -o ./epi_aproc_al
      T1alignedEPI=epi_aproc_al_res+orig
       
      # free 140MB, 12Gb!
      [ "$dirty" != "yes" ] && rm pb04* epi_aproc_al.{BRIK,HEAD}

      #restEPI=$mprageDir/rest_epi_RPI+orig


      #########################
      # get maskaverages for tissue masks (not used by physio)
      #########################

      # choices were $mprageDir/rest_epi_RPI+orig not $prprocDir/..._errts_al_res
      alert "making 1D regressors using $T1alignedEPI"

      ######
      # extract regressors  (depends on mask created by afni_proc)
      #####

      for regress in Vent WM_erod NBT_erod aseg_RPI mask_al; do
         # most things are in mprage folder, mask_al is in current directory
         srcdir=$mprageDir
         [[ $regress =~ mask_al ]] && srcdir=./

         3dresample -master $T1alignedEPI -inset  $srcdir/$regress+orig -prefix ./${regress}_res
         _overview "${regress}_res+orig" -$T1alignedEPI -$regress+orig  "resample mask";

         # resample masks to EPI
         # Vent+orig    -> Vent_res+orig
         # WM+orig      -> WM_res+orig
         # NBT_erod+orig-> NBT_erod_res+orig
         # aseg_RPI+orig-> aseg_RPI_res+orig
         # mask_al+orig -> mask_al_res+orig
      done



      for regress in Vent WM_erod NBT_erod; do
         #3dmaskave -mask ${regress}_res+orig  -q $restEPI  > ${regress%_erod*}.1D
         3dmaskave -mask ${regress}_res+orig  -q $T1alignedEPI  > ${regress%_erod*}.1D
         _overview "$mprageDir/${regress%_erod*}.1D" "-${regress}_res+orig" -$(basename $T1alignedEPI)  "maskave";

         ## extract regressors from FSL masks for use as nuisance regressors
         # Vent_res+orig    -> Vent.1D
         # WM_erod_res+orig -> WM.1D
         # NBT_erod_res+org -> NBT.1D
         # should maskave the bandpassed (this way is really bad)
         # should bandpass after anticore then do this!!! TODO
      done

      # global signal (use afni_proc output mask)
      #3dmaskave -mask full_mask.$subj+orig -quiet $restEPI  > Global.1D
      #_overview Global.1D -full_mask.$subj+orig -$(basename $restEPI) "maskave"
      3dmaskave -mask mask_al_res+orig -quiet $T1alignedEPI  > Global.1D
      _overview Global.1D -mask_al_res+orig -$(basename $T1alignedEPI ) "maskave"
      # use global signal/mean if no physo (slide 21 http://afni.nimh.nih.gov/pub/dist/edu/latest/afni_handouts/instastuff.pdf)
      # or per brain region a la http://languagescience.umd.edu/wiki/MRI-fMRI
      # BOTH suck according to http://afni.nimh.nih.gov/sscc/rwcox/papers/TroubleAtRest2012.pdf
      #3dmaskave -mask $nophysioDir/full_mask.$subj+orig -quiet $mprageDir/rest_epi_RPI+orig'[4..$]' > GS.1D
      #########################


      # motion
      1d_tool.py -infile dfile.rall.1D -set_nruns 1 -demean -write motion_demean.1D
      1d_tool.py -infile $nophysioDir/dfile.rall.1D -set_nruns 1 -derivative -demean -write motion_deriv.1D
      _overview "motion_demean.1D" -dfile.rall.1D  "demean"
      _overview "motion_deriv.1D" "-dfile.rall.1D" "demeaned derivatives of motion"
      
      # regressor derivs
      for needD in WM Vent Global; do 
         1d_tool.py -infile $needD.1D -set_nruns 1 -derivative -demean -write ${needD}_deriv.1D
         _overview "${needD}_deriv.1D" "-$needD.1D" "derivatives of regressors"
         #output: WM_deriv.1D Vent_deriv.1D Global_deriv.1D
      done

      # remove everything but final output
      #ls *[^D] |grep -v $T1alignedEPI | xargs rm
   else
     alert "afni proc, alingment, and regressors already done for $subj"
     T1alignedEPI=epi_aproc_al_res+orig
   fi




   ###################
   # Pipelines Diverge
   #  bp+ort_noPhyso
   #  bp+3dD_noPhyso 
   #  bp+3dD-better_noPhyso 
   ###################

   [[ $again =~ bp|bandpass || ! -d "$pipelineDir" ]] && fresh="yes" && alert "set fresh at nophysio bp"
   # should define pipelineoutfile here
   if [ "$fresh" = "yes" ]; then
      # Remove if fresh
      [ -d $pipelineDir ] && rm -r $pipelineDir

      # make dir and go there
      mkdir $pipelineDir && cd $pipelineDir
      stamp "start pipeline"

      alert "made $pipelineDir"

      ## do what the pipeline says to
      case  "$pipelineSuffix" in 
         #### good?
         bp+ort*) 
           graphstage=ort

           alert "using 'good' bp+ort pipeline" 
           ### 3dbandpass
           pipelineoutfile=epi_res_bp+orig 
           3dBandpass -prefix ./$pipelineoutfile 0.009 0.08 $nophysioDir/$T1alignedEPI \
            $(for r in {WM,Vent,Global}{,_deriv}.1D motion_{demean,deriv}; do echo -n "-ort $nophysioDir/$r "; done)
           #-ort WM.1D -ort WM_deriv.1D -ort Vent.1D -ort Vent_deriv.1D -ort Global.1D 
           #-ort Global_deriv.1D -ort motion_demean -ort motion_deriv 
           #TODO: include global?
            _overview "$pipelineoutfile" -$T1alignedEPI -motion_deriv.1D -motion_demean.1D \
                      -WM.1D -Vent.1D -Global.1D -WM_deriv.1D -Vent_deriv.1D \
                      -Global_deriv.1D "Bandpass"

         ;;

         #### bad
         # band pass input but not regressors 
         # then regress, re-introducing bandpassed noise
         bp+3dD_*)
           graphstage=3dD
           alert "using 'bad' bp+3dD pipeline" 

           bp=./${T1alignedEPI%+*}_bp+orig #epi_aproc_al_res+orig -> epi_aproc_al_res_bp+orig
           3dBandpass -prefix $bp 0.009 0.08 $nophysioDir/$T1alignedEPI
           _overview "$bp" -$T1alignedEPI "Bandpass"

           ### 3dD
           pipelineoutfile=${bp%+*}_3dDerrts+orig # epi_aproc_al_res_bp+orig -> epi_aproc_al_res_bp_3dDerrts+orig
           3dDeconvolve -input $bp -mask $mask_al_res                                                          \
                        -fitts fitts.${subj}  -errts ./$pipelineoutfile -bucket stats.${subj}                  \
                        -polort 3                                                                              \
                        -fout -tout -x1D X.xmat.1D -xjpeg X.jpg                                                \
                        -num_stimts 18                                                                         \
                        -stim_file 1  $nophysioDir/WM.1D                               -stim_label 1  stim01   \
                        -stim_file 2  $nophysioDir/Vent.1D                             -stim_label 2  stim02   \
                        -stim_file 3  $nophysioDir/Global.1D                           -stim_label 3  stim03   \
                        -stim_file 4  $nophysioDir/WM_deriv.1D                         -stim_label 4  stim04   \
                        -stim_file 5  $nophysioDir/Vent_deriv.1D                       -stim_label 5  stim05   \
                        -stim_file 6  $nophysioDir/Global_deriv.1D                     -stim_label 6  stim06   \
                        -stim_file 7  $nophysioDir/Motion_demean.1D'[0]' -stim_base 7  -stim_label 7  roll_01  \
                        -stim_file 8  $nophysioDir/Motion_demean.1D'[1]' -stim_base 8  -stim_label 8  pitch_01 \
                        -stim_file 9  $nophysioDir/Motion_demean.1D'[2]' -stim_base 9  -stim_label 9  yaw_01   \
                        -stim_file 10 $nophysioDir/Motion_demean.1D'[3]' -stim_base 10 -stim_label 10 dS_01    \
                        -stim_file 11 $nophysioDir/Motion_demean.1D'[4]' -stim_base 11 -stim_label 11 dL_01    \
                        -stim_file 12 $nophysioDir/Motion_demean.1D'[5]' -stim_base 12 -stim_label 12 dP_01    \
                        -stim_file 13 $nophysioDir/Motion_deriv.1D'[0]'  -stim_base 13 -stim_label 13 roll_02  \
                        -stim_file 14 $nophysioDir/Motion_deriv.1D'[1]'  -stim_base 14 -stim_label 14 pitch_02 \
                        -stim_file 15 $nophysioDir/Motion_deriv.1D'[2]'  -stim_base 15 -stim_label 15 yaw_02   \
                        -stim_file 16 $nophysioDir/Motion_deriv.1D'[3]'  -stim_base 16 -stim_label 16 dS_02    \
                        -stim_file 17 $nophysioDir/Motion_deriv.1D'[4]'  -stim_base 17 -stim_label 17 dL_02    \
                        -stim_file 18 $nophysioDir/Motion_deriv.1D'[5]'  -stim_base 18 -stim_label 18 dP_02    \
                        -GOFORIT 10                                                               \

            _overview "$pipelineoutfile" "-$bp" -motion_deriv.1D -motion_demean.1D \
                      -WM.1D -Vent.1D -Global.1D -WM_deriv.1D -Vent_deriv.1D -Global_deriv.1D -$(basename $mask_al_res) "Deconvolve"


           ### 3dbp
           ;;


         # accidentally made the better 'bandpass last' pipeline
         # keep around just in case
         bp+3dD-better_*)

           graphstage=better

           alert "using 'better' bp+3dD pipeline" 
           ### 3dD
           errts=${T1alignedEPI%+*}_3dDerrts+orig
           3dDeconvolve -input $nophysioDir/$T1alignedEPI  -mask $mask_al_res                                  \
                        -fitts fitts.${subj}  -errts ./$errts -bucket stats.${subj}                            \
                        -polort 3                                                                              \
                        -fout -tout -x1D X.xmat.1D -xjpeg X.jpg                                                \
                        -num_stimts 18                                                                         \
                        -stim_file 1  $nophysioDir/WM.1D                               -stim_label 1  stim01   \
                        -stim_file 2  $nophysioDir/Vent.1D                             -stim_label 2  stim02   \
                        -stim_file 3  $nophysioDir/Global.1D                           -stim_label 3  stim03   \
                        -stim_file 4  $nophysioDir/WM_deriv.1D                         -stim_label 4  stim04   \
                        -stim_file 5  $nophysioDir/Vent_deriv.1D                       -stim_label 5  stim05   \
                        -stim_file 6  $nophysioDir/Global_deriv.1D                     -stim_label 6  stim06   \
                        -stim_file 7  $nophysioDir/Motion_demean.1D'[0]' -stim_base 7  -stim_label 7  roll_01  \
                        -stim_file 8  $nophysioDir/Motion_demean.1D'[1]' -stim_base 8  -stim_label 8  pitch_01 \
                        -stim_file 9  $nophysioDir/Motion_demean.1D'[2]' -stim_base 9  -stim_label 9  yaw_01   \
                        -stim_file 10 $nophysioDir/Motion_demean.1D'[3]' -stim_base 10 -stim_label 10 dS_01    \
                        -stim_file 11 $nophysioDir/Motion_demean.1D'[4]' -stim_base 11 -stim_label 11 dL_01    \
                        -stim_file 12 $nophysioDir/Motion_demean.1D'[5]' -stim_base 12 -stim_label 12 dP_01    \
                        -stim_file 13 $nophysioDir/Motion_deriv.1D'[0]'  -stim_base 13 -stim_label 13 roll_02  \
                        -stim_file 14 $nophysioDir/Motion_deriv.1D'[1]'  -stim_base 14 -stim_label 14 pitch_02 \
                        -stim_file 15 $nophysioDir/Motion_deriv.1D'[2]'  -stim_base 15 -stim_label 15 yaw_02   \
                        -stim_file 16 $nophysioDir/Motion_deriv.1D'[3]'  -stim_base 16 -stim_label 16 dS_02    \
                        -stim_file 17 $nophysioDir/Motion_deriv.1D'[4]'  -stim_base 17 -stim_label 17 dL_02    \
                        -stim_file 18 $nophysioDir/Motion_deriv.1D'[5]'  -stim_base 18 -stim_label 18 dP_02    \
                        -GOFORIT 10                                                               \

            _overview "$errts" "-$T1alignedEPI" -motion_deriv.1D -motion_demean.1D \
                      -WM.1D -Vent.1D -Global.1D -WM_deriv.1D -Vent_deriv.1D -Global_deriv.1D -$(basename $mask_al_res) "3dDeconvolve"


           ### 3dbp
           pipelineoutfile=${errts%+*}_bp+orig 
           3dBandpass -prefix $pipelineoutfile 0.009 0.08 $errts
           _overview "$pipelineoutfile" -$errts "Bandpass"
           ;;

         *)  alert "unknown nophyso pipeline $pipelineSuffix, cannot finish";
             exit
           ;;
         esac

      else
       alert "already finished with bandpassing for $subj"
       cd $pipelineDir
       [ $again = "last" ] && fresh="yes"
       case  "$pipelineSuffix" in 
           bp+ort_*)        pipelineoutfile=epi_res_bp+orig  ;;
           bp+3dD_*)        pipelineoutfile=epi_aproc_al_res_bp_3dDerrts+orig ;;
           bp+3dD-better_*) pipelineoutfile=epi_aproc_al_res_bp_3dDerrts+orig ;;
       esac
      fi

    ;;

 *) alert "unknown pipeline $pipelineSuffix";  exit ;;
esac


### Wrap up for all pipelines
[ "$fresh" != "yes" ]      && echo "Didn't do anything,considered skipped" && exit 1
[ -z "$pipelineoutfile" ]  && echo "pipeline outfile is not set! Why?!"    && exit 1
[ -z "$mask_al_res" ]      && echo "mask_al_res is not set! Why?!"         && exit 1

# maybe don't blur here
3dBlurInMask -input $pipelineoutfile -FWHM 5 -mask $mask_al_res -preserve -prefix rest_preproc_native.nii.gz        
_overview rest_preproc_native.nii.gz   -$pipelineoutfile -$mask_al_res "Blur"
### OUTPUT: rest_preproc_native.nii.gz # rest_preproc_native.nii.gz is the preprocess file in native space

### FINAL MNI ALIGNED OUTPUT: rest_preproc_mni
# use output from rest_preprocessMprage
alert "final alignment" 
applywarp -i rest_preproc_native -r "$mniBrain" -o rest_preproc_mni -w "$mprageDir/mprage_RPI_warpcoef"

_overview rest_preproc_mni -MNI152_T1_2mm -rest_preproc_native  -mprage_RPI_warpcoef "warp"

# remove everything that's not the final (_native and _mni)
[ "$dirty" != "yes" ] && find ./ -type f \! -name rest_preproc_\* | xargs rm

stamp "finished pipeline"
##### Collect corrilation between 244 ROIs

alert "ROI stats" 

# check we have a fca directory, and go there
fcaDir=../fca/
[ -d $fcaDir ] || mkdir $fcaDir
cd $fcaDir

# save the corr as the pipeline but with _ instead of +
@ROI_Corr_Mat -zval -ts $pipelineDir/rest_preproc_mni.nii.gz -roi $bb244 -prefix ${pipelineSuffix//+/_}
[ "$dirty" != "yes" ] && rm *{BRIK,HEAD}

_overview "${pipelineSuffix//+/_}.corr.1D" -rest_preproc_mni -bb244 "ROI_Corr_Mat"

### save last bit of graph file
echo "}" >> $graphFile



exit 

# get a shot of the final alignment
#afni -com "SET_UNDERLAY rest_preproc_native.nii.gz" -com "SET_OVERLAY $pipelineDir/aseg_RPI_res+orig" -com "SET_PBAR_ALL A.+99 1.0 ROI_i128" -com "SET_XHAIRS OFF" -com "OPEN_WINDOW coronalimage opacity=7" -com "OPEN_WINDOW axialimage opacity=7" -com "OPEN_WINDOW sagittalimage opacity=7"  -yesplugouts -com "SAVE_PNG sagittalimage sag.png" -com "SAVE_PNG axialimage ax.png" -com "SAVE_PNG coronalimage cor.png" -com "QUIT"
#convert \( +append ax.png cor.png sag.png \) -scale 200% -fill yellow -annotate 1 $subj ${subj}_asegONepi.png
#rm {ax,cor,sag}.png


